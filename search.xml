<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数组的扩展</title>
    <url>/2020/08/04/%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h1 id="ES6总结系列之-数组的扩展-篇"><a href="#ES6总结系列之-数组的扩展-篇" class="headerlink" title="ES6总结系列之 数组的扩展 篇"></a>ES6总结系列之 数组的扩展 篇</h1><hr>
<h2 id="1-扩展运算符-…"><a href="#1-扩展运算符-…" class="headerlink" title="1.扩展运算符(…)"></a>1.扩展运算符(…)</h2><h3 id="①扩展运算符-spread-好比rest参数的逆运算，将一个数组转化为逗号分隔的参数序列，可以想象成去掉中括号"><a href="#①扩展运算符-spread-好比rest参数的逆运算，将一个数组转化为逗号分隔的参数序列，可以想象成去掉中括号" class="headerlink" title="①扩展运算符(spread)好比rest参数的逆运算，将一个数组转化为逗号分隔的参数序列，可以想象成去掉中括号[]"></a>①扩展运算符(spread)好比rest参数的<strong>逆运算</strong>，将一个数组转化为逗号分隔的参数序列，可以想象成去掉中括号<code>[]</code></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>

<h3 id="②扩展运算符后面还可以放置表达式"><a href="#②扩展运算符后面还可以放置表达式" class="headerlink" title="②扩展运算符后面还可以放置表达式"></a>②扩展运算符后面还可以放置表达式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  ...(x &gt; <span class="number">0</span> ? [<span class="string">'a'</span>] : []),</span><br><span class="line">  <span class="string">'b'</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h3 id="③可以实现数组深拷贝"><a href="#③可以实现数组深拷贝" class="headerlink" title="③可以实现数组深拷贝"></a>③可以实现数组深拷贝</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br></pre></td></tr></table></figure>

<h2 id="2-Array-from-arr-fn-item-index-–返回一个新数组"><a href="#2-Array-from-arr-fn-item-index-–返回一个新数组" class="headerlink" title="2.Array.from(arr, fn(item,index)) –返回一个新数组"></a>2.Array.from(arr, fn(item,index)) –返回一个新数组</h2><p>Array.from方法将：<strong>类似数组</strong>的对象（array-like object）和可<strong>遍历（iterable）的对象</strong>（包括 ES6 新增的数据结构 Set 和 Map）两类对象<strong>转为</strong>真正的<strong>数组</strong>。<br>常见的类数组有<code>arguments</code>和<code>NodeList</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].prototype.slice.call(arrayLike); <span class="comment">// ['a', 'b', 'c']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure>

<p>Array.from还可以接受<strong>第二个参数</strong>，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike, x =&gt; x * x);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike).map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (x) =&gt; x * x)</span><br><span class="line"><span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Array-of-a-b-c-a-b-c"><a href="#3-Array-of-a-b-c-a-b-c" class="headerlink" title="3.Array.of(a,b,c) //[a, b, c]"></a>3.Array.of(a,b,c) //[a, b, c]</h2><p>Array.of方法用于将一组<strong>值</strong>转化为<strong>数组</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>弥补数组构造函数<code>Array()</code>的不足,只有当参数个数<strong>不少于 2</strong> 个时，<code>Array()</code>才会返回由参数组成的<strong>新数组</strong>。参数个数只有<strong>一个</strong>时，实际上是<strong>指定数组的长度</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>() <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure>
<p><code>rest</code>参数同理:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>


<h2 id="总结要点"><a href="#总结要点" class="headerlink" title="总结要点"></a>总结要点</h2><p>扩展运算符 …</p>
<ol>
<li>可以实现数组深拷贝 arr = [1,2,3]  arr1 = […arr];</li>
<li>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。</li>
<li>Generator 函数运行后，返回一个遍历器对象</li>
<li>没有 Iterator 接口的对象，使用扩展运算符，将会报错</li>
<li>扩展运算符后面可加表达式    …(x &gt; 0 ? [‘a’] : [])</li>
<li>扩展运算符后面如果是一个空字符串，则不产生任何效果.</li>
<li>只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错.</li>
<li>如果扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错， </li>
</ol>
<p>常见的类数组：arguments、NodeList</p>
<p>Array.from(arr, fn(ele,index)) –返回一个新数组</p>
<ol>
<li>将<code>类数组</code>（具有length属性就行）和可遍历的对象（具有Iterat）转换为数组</li>
<li>回调函数类似于map（fn（ele,index））</li>
<li>支持第三个参数：用来绑定map里面的this</li>
</ol>
<p>Array.of(a,b,c) //[a,b,c]</p>
<ol>
<li>将一组值转化为数组</li>
<li>弥补Array()参数为一个时为指定<code>length</code>的缺陷</li>
</ol>
<hr>
<ul>
<li><a href https: github.com yoursjoker"" title="欢迎stars">个人Github</a>，欢迎star^_^</li>
<li>ES6总结系列参考自阮一峰《ECMAScript6入门》</li>
</ul>
]]></content>
      <categories>
        <category>ES6入门</category>
      </categories>
      <tags>
        <tag>ES6入门</tag>
      </tags>
  </entry>
  <entry>
    <title>函数的扩展</title>
    <url>/2020/08/03/%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h1 id="ES6总结系列之-函数的扩展-篇"><a href="#ES6总结系列之-函数的扩展-篇" class="headerlink" title="ES6总结系列之 函数的扩展 篇"></a>ES6总结系列之 函数的扩展 篇</h1><hr>
<h2 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h2><h3 id="参数变量是默认声明的，所以不能用let或const再次声明"><a href="#参数变量是默认声明的，所以不能用let或const再次声明" class="headerlink" title="参数变量是默认声明的，所以不能用let或const再次声明"></a>参数变量是默认声明的，所以不能用let或const再次声明</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = <span class="number">5</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">2</span>; <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">3</span>; <span class="comment">//不报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用参数默认值时，函数不能有同名参数"><a href="#使用参数默认值时，函数不能有同名参数" class="headerlink" title="使用参数默认值时，函数不能有同名参数"></a>使用参数默认值时，函数不能有同名参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, x, y</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, x, y = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参数默认值是惰性求值的，每次都重新计算默认值"><a href="#参数默认值是惰性求值的，每次都重新计算默认值" class="headerlink" title="参数默认值是惰性求值的，每次都重新计算默认值"></a>参数默认值是惰性求值的，每次都重新计算默认值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">99</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p = x + <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line">foo() <span class="comment">// 101</span></span><br><span class="line"><span class="comment">//每次调用函数foo时都会重新计算参数x+1</span></span><br></pre></td></tr></table></figure>

<h3 id="函数length属性失真，不包括默认值参数，rest参数"><a href="#函数length属性失真，不包括默认值参数，rest参数" class="headerlink" title="函数length属性失真，不包括默认值参数，rest参数"></a>函数<code>length</code>属性失真，不包括默认值参数，rest参数</h3><p><code>length</code>属性在有指定默认值的函数中，只返回<strong>没有默认值</strong>的参数的个数。即在<strong>有默认值参数</strong>的函数中，<code>length</code>将<strong>失真</strong>.<br>这是因为<code>length</code>属性的含义是，该函数<strong>预期</strong>传入的参数个数。某个参数<strong>指定默认值</strong>以后，预期传入的参数个数就<strong>不包括</strong>这个参数了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">0</span>, b, c</span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p><code>rest</code>参数同理:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>设置了<strong>参数默认值</strong>，函数进行<strong>声明初始化时</strong>，参数会形成一个<strong>单独作用域</strong>，等到初始化结束，这个作用域就会消失。这种语法行为，在<strong>不设置参数默认值时</strong>，是<strong>不会出现</strong>的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">2</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>下面是更复杂的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = function(</span>) </span>&#123; x = <span class="number">2</span>; &#125;) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">  y();<span class="comment">//y函数中的x指向参数x</span></span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 3</span></span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = function(</span>) </span>&#123; x = <span class="number">2</span>; &#125;) &#123;</span><br><span class="line">  x = <span class="number">3</span>;<span class="comment">//x与参数x是一致的</span></span><br><span class="line">  y();<span class="comment">//y函数中的x指向参数x</span></span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 2</span></span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><h3 id="rest参数形式为-变量名"><a href="#rest参数形式为-变量名" class="headerlink" title="rest参数形式为(...变量名)"></a>rest参数形式为(<code>...变量名</code>)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>rest 参数之后不能再有其他参数（即只能<strong>是最后一个参数</strong>），否则会报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, ...b, c</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的<code>length</code>属性，不包括 <code>rest</code> 参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;&#125;).length  <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">...a</span>) </span>&#123;&#125;).length  <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a, ...b</span>) </span>&#123;&#125;).length  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h3 id="①箭头函数里的this就是定义所在的对象，不是使用时所在的对象，箭头函数没有自己的this，导致内部的this就是外层代码块中的this"><a href="#①箭头函数里的this就是定义所在的对象，不是使用时所在的对象，箭头函数没有自己的this，导致内部的this就是外层代码块中的this" class="headerlink" title="①箭头函数里的this就是定义所在的对象，不是使用时所在的对象，箭头函数没有自己的this，导致内部的this就是外层代码块中的this"></a>①箭头函数里的this就是定义所在的对象，不是使用时所在的对象，箭头函数没有自己的this，导致内部的this就是外层代码块中的this</h3><h3 id="②由于箭头函数没有自己的this，所以当然也不能用call-apply-bind-改变this指向"><a href="#②由于箭头函数没有自己的this，所以当然也不能用call-apply-bind-改变this指向" class="headerlink" title="②由于箭头函数没有自己的this，所以当然也不能用call(), apply(), bind()改变this指向"></a>②由于箭头函数没有自己的this，所以当然也不能用call(), apply(), bind()改变this指向</h3><h3 id="③不可以用作构造函数，即不可以使用new命令（没有this）"><a href="#③不可以用作构造函数，即不可以使用new命令（没有this）" class="headerlink" title="③不可以用作构造函数，即不可以使用new命令（没有this）"></a>③不可以用作构造函数，即不可以使用new命令（没有this）</h3><h3 id="④不存在arguments对象，可用rest参数代替"><a href="#④不存在arguments对象，可用rest参数代替" class="headerlink" title="④不存在arguments对象，可用rest参数代替"></a>④不存在arguments对象，可用rest参数代替</h3><h3 id="⑤对象不构成单独的作用域"><a href="#⑤对象不构成单独的作用域" class="headerlink" title="⑤对象不构成单独的作用域"></a>⑤对象不构成单独的作用域</h3><p>导致jumps箭头函数定义时的作用域就是全局作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cat = &#123; </span><br><span class="line">    lives: <span class="number">9</span>, </span><br><span class="line">    jumps: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">this</span>.lives--; &#125;<span class="comment">//指向全局作用域</span></span><br><span class="line">&#125;</span><br><span class="line">ES6新增了大括号&#123;&#125;表示的块级作用域,但是对象并不构成单独的作用域</span><br></pre></td></tr></table></figure>

<h2 id="总结要点"><a href="#总结要点" class="headerlink" title="总结要点"></a>总结要点</h2><p>函数参数默认值</p>
<ul>
<li>参数变量是默认声明的，所以不能用let或const再次声明</li>
<li>使用参数默认值时，函数不能有同名参数</li>
<li>函数<code>length</code>属性失真，<strong>不包括</strong>默认值参数，rest参数</li>
<li>参数默认值是<strong>惰性求值</strong>的，每次都<strong>重新计算默认值</strong></li>
<li>作用域：设置了<strong>参数默认值</strong>，函数进行<strong>声明初始化时</strong>，参数会形成一个<strong>单独作用域</strong></li>
</ul>
<p><code>rest</code>参数</p>
<ul>
<li>rest参数形式为(<code>...变量名</code>)</li>
<li>rest 参数之后不能再有其他参数（即只能<strong>是最后一个参数</strong>），否则会报错</li>
<li>函数的<code>length</code>属性，不包括 <code>rest</code> 参数。</li>
</ul>
<p>箭头函数</p>
<ul>
<li>箭头函数里的this就是<strong>定义所在的对象</strong>，不是使用时所在的对象，<strong>箭头函数没有自己的this</strong>，导致内部的this就是外层代码块中的this</li>
<li>由于箭头函数没有自己的this，所以当然也<strong>不能</strong>用call(), apply(), bind()<strong>改变this指向</strong></li>
<li>不可以用作构造函数，即不可以使用new命令（没有this）</li>
<li><strong>不存在</strong>arguments对象，可用rest参数代替</li>
<li><strong>对象</strong>不构成单独的作用域</li>
</ul>
<hr>
<ul>
<li><a href https: github.com yoursjoker"" title="欢迎stars">个人Github</a>，欢迎star^_^</li>
<li>ES6总结系列参考自阮一峰《ECMAScript6入门》</li>
</ul>
]]></content>
      <categories>
        <category>ES6入门</category>
      </categories>
      <tags>
        <tag>ES6入门</tag>
      </tags>
  </entry>
  <entry>
    <title>模板字符串</title>
    <url>/2020/08/03/%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="ES6总结系列之-模板字符串-篇"><a href="#ES6总结系列之-模板字符串-篇" class="headerlink" title="ES6总结系列之 模板字符串 篇"></a>ES6总结系列之 模板字符串 篇</h1><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>模板字符串由一对<strong>反引号</strong>标识符组成，<code>${}</code>为取值表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"Tony"</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span> ;</span><br><span class="line">name+<span class="string">"今年"</span>+age+<span class="string">"岁"</span> ;</span><br><span class="line"><span class="comment">//"Tony今年18岁"</span></span><br><span class="line">等价于</span><br><span class="line"><span class="string">`<span class="subst">$&#123;name&#125;</span>今年<span class="subst">$&#123;age&#125;</span>岁了`</span>;</span><br><span class="line"><span class="comment">//"Tony今年18岁"</span></span><br></pre></td></tr></table></figure>
<p>我们用传统写法表达字符串和变量的拼接写法非常冗余，ES6的模板字符串就可以很好的解决这个问题</p>
<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul>
<li>模板字符串中如需用反引号，需要用\转义<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"Tony"</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="string">`\`<span class="subst">$&#123;name&#125;</span>\`今年<span class="subst">$&#123;age&#125;</span>岁`</span>;</span><br><span class="line"><span class="comment">//"`Tony`今年18岁"</span></span><br></pre></td></tr></table></figure></li>
<li>如果大括号里面的值不是字符串，则按照一般规则装换为字符（toString方法），特别注意的是，如果大括号里面是对象，则将返回<code>[object Object]</code>,如下面代码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="string">`abc<span class="subst">$&#123;obj&#125;</span>`</span>;</span><br><span class="line"><span class="comment">//"abc[object Object]"</span></span><br></pre></td></tr></table></figure>


<ul>
<li>大括号里面就是执行JavaScript代码，因此如果大括号内部是字符串，就会将原样输出<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">大括号里面是表达式，计算后输出</span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span></span><br><span class="line"><span class="comment">// "1 + 2 = 3"</span></span><br><span class="line"></span><br><span class="line">大括号里面是字符串，将原样输出</span><br><span class="line"><span class="string">`<span class="subst">$&#123;<span class="string">"Hello World"</span>&#125;</span>`</span></span><br><span class="line"><span class="comment">//"Hello World"</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>模版字符串所有的<strong>空格和缩进</strong>都会被<strong>保留</strong>在输出之中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newLis = <span class="string">"&lt;li&gt;1:aaa&lt;/li&gt;"</span></span><br><span class="line"><span class="keyword">let</span> ul = </span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;newLis&#125;</span></span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;ul&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;1:aaa&lt;/li&gt;</span></span><br><span class="line"><span class="comment">&lt;/ul&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>模板字符串可嵌套</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"Tony"</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span> ;</span><br><span class="line"><span class="string">`<span class="subst">$&#123;name&#125;</span>今年<span class="subst">$&#123;<span class="string">`<span class="subst">$&#123;age&#125;</span>`</span>&#125;</span>岁了`</span>;</span><br><span class="line"><span class="comment">//"Tony今年18岁了"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>标签模板，函数名+模板字符串，其实就是另外一种调用函数的表达</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"Tony"</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span> ;</span><br><span class="line">fn<span class="string">`<span class="subst">$&#123;name&#125;</span>今年<span class="subst">$&#123;age&#125;</span>岁了`</span>;</span><br><span class="line"><span class="comment">//&#123; '0': [ '', '今年', '岁了' ], '1': 'Tony', '2': 18 &#125;</span></span><br><span class="line"></span><br><span class="line">等同于</span><br><span class="line">fn([ <span class="string">''</span>, <span class="string">'今年'</span>, <span class="string">'岁了'</span> ], <span class="string">'Tony'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="comment">//&#123; '0': [ '', '今年', '岁了' ], '1': 'Tony', '2': 18 &#125;</span></span><br></pre></td></tr></table></figure>
<p>返回的<code>arguments</code>第一个属性包含了所有的除了变量外的部分，变量在后面逐个显示；注意第一个数组个数总是要比变量多一个，可以把<code>${name}今年${name}岁了</code>看成一条线，把每个变量<code>${name}</code> <code>${name}</code>看成是一个分割点，分割的结果总是分割点多一份；如果变量位于首尾的时候会分割出一个空字符串<code>&#39;&#39;</code>;</p>
</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>模板字符串中如需用反引号，需要用\转义</li>
<li>模版字符串所有的<strong>空格和缩进</strong>都会被<strong>保留</strong>在输出之中</li>
<li>字符串里可以嵌套变量，大括号里内部可以放入<strong>任意的JavaScript表达式</strong>，可以进行运算，以及引用对象属性，函数</li>
<li>模板字符串可嵌套</li>
<li>使用标签模板，注意<code>arguments</code>第一个数包含所有非变量部分，且数量总比变量多一个</li>
</ul>
<hr>
<p>ES6总结系列参考自阮一峰大神的《ES6入门教程》</p>
]]></content>
      <categories>
        <category>ES6入门</category>
      </categories>
      <tags>
        <tag>ES6入门</tag>
      </tags>
  </entry>
  <entry>
    <title>解构赋值</title>
    <url>/2020/08/03/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<h1 id="ES6总结系列之-变量的解构赋值-篇"><a href="#ES6总结系列之-变量的解构赋值-篇" class="headerlink" title="ES6总结系列之 变量的解构赋值 篇"></a>ES6总结系列之 变量的解构赋值 篇</h1><p>变量的解构赋值：<strong>分解</strong>一个对象的结构，对变量进行<strong>赋值</strong>，前提：等号两边的<strong>模式相同</strong></p>
<h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><p>可从数组中提取值，按照<strong>对应位置</strong>，对变量赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"> <span class="comment">//a=1,b=2,c=3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , ,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; </span><br><span class="line"><span class="comment">//省略赋值  c=3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="comment">//嵌套解构 a=1,c=2,c=3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a] = [];</span><br><span class="line"><span class="comment">//结构不成功，变量的的值就等于undefined， 所以a = undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>，j = <span class="number">1</span>] = [<span class="literal">undefined</span>, <span class="literal">null</span>];</span><br><span class="line"><span class="comment">//x = 1; j = null;</span></span><br><span class="line"><span class="comment">//解构指定默认值， 只有严格等于(===)undefined是才起作用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认值为表达式时，其求值时惰性的，即需要用时才计算，如下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br><span class="line"><span class="comment">//上面代码中，因为x能取到值，所以函数f根本不会执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];     <span class="comment">// x=1; y=1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];    <span class="comment">// x=2; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError: y is not defined</span></span><br><span class="line"><span class="comment">//默认值可以引用解构赋值的其他变量，但该变量必须已经声明</span></span><br><span class="line"><span class="comment">//上面最后一个表达式之所以会报错，是因为x用y做默认值时，y还没有声明。</span></span><br></pre></td></tr></table></figure>

<h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><p>对象的属性<strong>没有次序</strong>，变量必须与属性<strong>同名</strong>，才能取到正确的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="comment">//foo = 'aaa';  bar = 'bbb';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//变量名与属性名不一样,应写成</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span> : a, <span class="attr">bar</span> : b &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="comment">//a = 'aaa'; b = 'bbb'</span></span><br><span class="line"><span class="comment">//foo = undefined; bar = underfined;</span></span><br><span class="line"><span class="comment">//对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="comment">//baz = undefined  找不到名为baz的属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line"><span class="comment">//y = 3  指定默认值</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line">a <span class="comment">// "h"</span></span><br><span class="line">b <span class="comment">// "e"</span></span><br><span class="line">c <span class="comment">// "l"</span></span><br><span class="line">d <span class="comment">// "l"</span></span><br><span class="line">e <span class="comment">// "o"</span></span><br><span class="line"></span><br><span class="line">类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。</p>
<h2 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;&#125;)</span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。</p>
<h2 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特别注意,当大括号位于行首时，JavaScript 引擎会将&#123;x&#125;理解成一个代码块，从而发生语法错误。，可通过加圆括号解决，如下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">仅赋值语句的非模式部分，可以使用圆括号。</span><br><span class="line"></span><br><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<h2 id="总结要点"><a href="#总结要点" class="headerlink" title="总结要点"></a>总结要点</h2><ul>
<li>解构赋值<strong>本质</strong>是<strong>对象的解构</strong>，只要等号<strong>右边</strong>的值<strong>不是对象或数组</strong>，就先将其<strong>转为对象</strong>。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</li>
<li>只要某种数据结构具有 Iterator 接口，就可以用于数组的解构赋值，如arguments类数组对象，NodeList类数组对象</li>
<li>对象的解构赋值可以取到<strong>继承的属性</strong></li>
<li>默认值生效的条件是，解构的值<strong>严格</strong>等于undefined</li>
<li>仅赋值语句的非模式部分，可以使用圆括号。</li>
</ul>
<hr>
<ul>
<li><a href https: github.com yoursjoker"" title="欢迎stars">个人Github</a>，欢迎star鼓励一下</li>
<li>ES6总结系列参考自阮一峰《ECMAScript6入门》</li>
</ul>
]]></content>
      <categories>
        <category>ES6入门</category>
      </categories>
      <tags>
        <tag>ES6入门</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的CSS之BFC和margin塌陷</title>
    <url>/2020/04/02/BFC-MarginCollapse/</url>
    <content><![CDATA[<h2 id="CSS之BFC，margin塌陷篇"><a href="#CSS之BFC，margin塌陷篇" class="headerlink" title="CSS之BFC，margin塌陷篇"></a>CSS之BFC，margin塌陷篇</h2><p>大家好，我是YoursJoker，想要走出大山的一个小菜鸟，今天将用简单易懂的语言，让大家快速了解和掌握CSS中的BFC和margin塌陷（本人新手一枚，各位大佬们多多包涵）</p>
<h3 id="何为BFC"><a href="#何为BFC" class="headerlink" title="何为BFC"></a>何为BFC</h3><p>BFC就是块级格式化上下文<code>block formatting context</code></p>
<hr>
<h3 id="BFC特性："><a href="#BFC特性：" class="headerlink" title="BFC特性："></a>BFC特性：</h3><ul>
<li>BFC就是页面上的一个<strong>隔离的独立容器</strong>，容器里的子元素不会影响到外面的元素</li>
<li>计算BFC高度时，浮动元素会被计算进去，可用于<strong>清除浮动</strong></li>
<li>内部的Box会在垂直方向，从顶部开始一个接一个的放置，相当于文档流</li>
<li>Box垂直方向的距离由margin决定，会<strong>叠加</strong>，而不是取<code>margin-bottom</code>和<code>margin-top</code>的最大值，可<strong>解决margin塌陷</strong>，关于margin塌陷滑下手指就能看到啦</li>
</ul>
<hr>
<h3 id="触发bfc条件"><a href="#触发bfc条件" class="headerlink" title="触发bfc条件"></a>触发bfc条件</h3><ul>
<li>position：absolute/fixed</li>
<li>display:inline-block</li>
<li>float:right/left</li>
<li>overflow:不为visible(<code>scroll</code>/<code>hidden</code>/<code>auto</code>)</li>
</ul>
<hr>
<h3 id="margin塌陷"><a href="#margin塌陷" class="headerlink" title="margin塌陷"></a>margin塌陷</h3><ul>
<li>兄弟元素：<strong>垂直方向</strong>的<code>margin</code>会出现合并，即只取前一个元素margin-bottom或后一个元素margin-top两者的较大值；<strong>水平方向</strong>不会出现合并，会正常叠加</li>
<li>父子元素：子元素设置<code>margin-top</code>时会忽视父元素上边,有点像挡不住子元素，子元素“逃”出去了，干说不是很很清楚，直接上代码吧<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div class=<span class="string">"father"</span>&gt;              //父元素红色</span><br><span class="line">	&lt;div class=<span class="string">"son"</span>&gt;&lt;/div&gt;     //子元素黑色</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.father&#123;</span><br><span class="line">	width: 200px;</span><br><span class="line">	height: 200px;</span><br><span class="line">	background-color: <span class="comment">#f00;</span></span><br><span class="line">	&#125;</span><br><span class="line">.item1&#123;</span><br><span class="line">	margin-top: 20px;         //子元素设置margin-top</span><br><span class="line">	width: 50px;</span><br><span class="line">	height: 50px;</span><br><span class="line">	background-color: <span class="comment">#000;</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<img src="https://user-gold-cdn.xitu.io/2020/4/2/17136db2299cfdc0?w=252&h=252&f=png&s=1824" alt title="理想中的样子"> <img src="https://user-gold-cdn.xitu.io/2020/4/2/17136db4bffaab8f?w=250&h=281&f=png&s=1773" alt title="可现实呜呜呜"><br>理想的样子是子元素距离父元素上边距<code>20px</code>,可实际是子元素直接“忽略”了父元素<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3></li>
<li>最直接给父元素设置<code>border-wide</code>，可我们往往不需要这个边框，影响美观，这时就可采用下面这种方法</li>
<li>可用前面所讲的bfc解决margin塌陷问题</li>
</ul>
<hr>
<ul>
<li>浮动元素产生了浮动流：所有产生了浮动流的元素，块级元素看不到他们</li>
<li>产生了bfc的元素、文本类型属性(包括<code>inline</code> <code>inline-block</code>的）文本都能看到浮动元素(图片配合float可以形成环绕文字的效果哦！)。</li>
<li>设置了<code>position:absolute</code>和<code>float:left/right</code>的元素会变成inline-block元素</li>
</ul>
<p><a href https: github.com yoursjoker"" title="欢迎stars">个人Github</a>，欢迎stars鼓励一下<br><a href https: yoursjoker.github.io "">个人博客</a>，刚建立不久的博客，有空的大佬可以过来提提建议</p>
]]></content>
      <categories>
        <category>CSS特别篇</category>
      </categories>
      <tags>
        <tag>CSS特别篇</tag>
      </tags>
  </entry>
  <entry>
    <title>let,const ES6入门</title>
    <url>/2020/03/31/let,const%20ES6%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>大家好我是YoursJoker，一个知道很多关于鲁迅名言的前端小萌新，可能鲁迅不会承认（哈哈）<br>个人Blog：<a href="https://yoursjoker.github.io/">https://yoursjoker.github.io/</a> 刚建立，求有空大佬们过来提提意见<br>github:<a href="https://github.com/YoursJoker" target="_blank" rel="noopener">https://github.com/YoursJoker</a> 欢迎star（目前是真空的，我会加油逐步完善）</p>
<h2 id="let命令和const命令"><a href="#let命令和const命令" class="headerlink" title="let命令和const命令"></a>let命令和const命令</h2><p>ES6新增的<code>let</code>命令和<code>const</code>命令和<code>var</code>类似，都是用来<code>声明变量</code>的</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li><code>let</code> <code>const</code>只在声明的<code>块级作用域</code>生效</li>
</ul>
<blockquote>
<ol>
<li>在ES6之前只有 <em>全局作用域</em> 和 <em>函数作用域</em></li>
<li>ES6新增了大括号{}表示的块级作用域，可嵌套</li>
</ol>
</blockquote>
<ul>
<li><code>let</code> <code>const</code>预编译声明不会提前</li>
</ul>
<blockquote>
<ol>
<li><strong>暂时性死区</strong>temporal dead zone简称 TDZ，当使用<code>let</code> <code>const</code>命令时，区块中的<code>let</code> <code>const</code>命令声明的变量从一开始就形成了封闭作用域，凡是在<strong>声明前使用</strong>都会报错</li>
<li><strong>特别注意</strong>：声明前使用typeof也会报错，而ES6之前typeof是一个绝对安全的函数</li>
</ol>
</blockquote>
<ul>
<li>不可以重复定义<blockquote>
<ol>
<li><code>let</code> <code>const</code>在同一个代码块不可以重复定义，否则会报错</li>
</ol>
</blockquote>
<h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3></li>
</ul>
<p>1.<code>for</code>循环中用<code>let</code>声明的迭代变量每次都是<strong>新的变量</strong>，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 6</span><br></pre></td></tr></table></figure>
<p>每一次循环的i其实都是一个<strong>新的变量</strong>,<code>JavaScript</code><strong>引擎内部</strong>会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算</p>
<p>2.<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个<strong>父作用域</strong>，而循环体内部是一个单独的<strong>子作用域</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  <span class="built_in">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  console.log(i);&#125;</span><br><span class="line">// abc// abc// abc</span><br></pre></td></tr></table></figure>
<p><code>a</code>声明了两次，表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域</p>
<h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><p><code>const</code>命令定义时<strong>必须初始化</strong><br><code>const</code>定义的变量为原始值时不可改变，为引用值时对象的属性可以改</p>
<p>###顶层对象的属性</p>
<ol>
<li>在浏览器环境指的是<code>window</code>对象，<code>window</code>也有实体含义，指的是<strong>浏览器的窗口对象</strong></li>
<li>在Node指的是<code>global</code>对象</li>
<li><strong>ES5</strong>中<strong>顶层对象的属性</strong>和<strong>全局变量</strong>是<strong>等价</strong>的</li>
<li>ES6中为了保持兼容性<br>①<code>var</code>命令和<code>function</code>命令声明的全局变量，<strong>依旧是</strong>顶层对象的属性<br>②<code>let</code>命令,<code>const</code>命令,<code>class</code>命令声明的全局变量，<strong>不属于顶层对象的属性</strong></li>
<li><code>globalThis</code>对象，2020新增顶层对象，在<strong>任何环境下<code>globalThis</code>都存在</strong>，都可以拿到顶层对象，指向<strong>全局环境下的this</strong></li>
</ol>
<hr>
<p>ES6入门参考自阮一峰《ES6入门教程》</p>
]]></content>
      <categories>
        <category>ES6入门</category>
      </categories>
      <tags>
        <tag>ES6入门</tag>
      </tags>
  </entry>
  <entry>
    <title>First-aticle</title>
    <url>/2020/03/30/First-aticle/</url>
    <content><![CDATA[<p>无中生有<br>暗度陈仓<br>偷梁换柱</p>
]]></content>
  </entry>
</search>
