<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>你不知道的CSS之BFC和margin塌陷</title>
    <url>/2020/04/02/BFC-MarginCollapse/</url>
    <content><![CDATA[<h2 id="CSS之BFC，margin塌陷篇"><a href="#CSS之BFC，margin塌陷篇" class="headerlink" title="CSS之BFC，margin塌陷篇"></a>CSS之BFC，margin塌陷篇</h2><p>大家好，我是YoursJoker，想要走出大山的一个小菜鸟，今天将用简单易懂的语言，让大家快速了解和掌握CSS中的BFC和margin塌陷（本人新手一枚，各位大佬们多多包涵）</p>
<h3 id="何为BFC"><a href="#何为BFC" class="headerlink" title="何为BFC"></a>何为BFC</h3><p>BFC就是块级格式化上下文<code>block formatting context</code></p>
<hr>
<h3 id="BFC特性："><a href="#BFC特性：" class="headerlink" title="BFC特性："></a>BFC特性：</h3><ul>
<li>BFC就是页面上的一个<strong>隔离的独立容器</strong>，容器里的子元素不会影响到外面的元素</li>
<li>计算BFC高度时，浮动元素会被计算进去，可用于<strong>清除浮动</strong></li>
<li>内部的Box会在垂直方向，从顶部开始一个接一个的放置，相当于文档流</li>
<li>Box垂直方向的距离由margin决定，会<strong>叠加</strong>，而不是取<code>margin-bottom</code>和<code>margin-top</code>的最大值，可<strong>解决margin塌陷</strong>，关于margin塌陷滑下手指就能看到啦</li>
</ul>
<hr>
<h3 id="触发bfc条件"><a href="#触发bfc条件" class="headerlink" title="触发bfc条件"></a>触发bfc条件</h3><ul>
<li>position：absolute/fixed</li>
<li>display:inline-block</li>
<li>float:right/left</li>
<li>overflow:不为visible(<code>scroll</code>/<code>hidden</code>/<code>auto</code>)</li>
</ul>
<hr>
<h3 id="margin塌陷"><a href="#margin塌陷" class="headerlink" title="margin塌陷"></a>margin塌陷</h3><ul>
<li>兄弟元素：<strong>垂直方向</strong>的<code>margin</code>会出现合并，即只取前一个元素margin-bottom或后一个元素margin-top两者的较大值；<strong>水平方向</strong>不会出现合并，会正常叠加</li>
<li>父子元素：子元素设置<code>margin-top</code>时会忽视父元素上边,有点像挡不住子元素，子元素“逃”出去了，干说不是很很清楚，直接上代码吧<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div class=<span class="string">"father"</span>&gt;              //父元素红色</span><br><span class="line">	&lt;div class=<span class="string">"son"</span>&gt;&lt;/div&gt;     //子元素黑色</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.father&#123;</span><br><span class="line">	width: 200px;</span><br><span class="line">	height: 200px;</span><br><span class="line">	background-color: <span class="comment">#f00;</span></span><br><span class="line">	&#125;</span><br><span class="line">.item1&#123;</span><br><span class="line">	margin-top: 20px;         //子元素设置margin-top</span><br><span class="line">	width: 50px;</span><br><span class="line">	height: 50px;</span><br><span class="line">	background-color: <span class="comment">#000;</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<img src="https://user-gold-cdn.xitu.io/2020/4/2/17136db2299cfdc0?w=252&h=252&f=png&s=1824" alt title="理想中的样子"> <img src="https://user-gold-cdn.xitu.io/2020/4/2/17136db4bffaab8f?w=250&h=281&f=png&s=1773" alt title="可现实呜呜呜"><br>理想的样子是子元素距离父元素上边距<code>20px</code>,可实际是子元素直接“忽略”了父元素<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3></li>
<li>最直接给父元素设置<code>border-wide</code>，可我们往往不需要这个边框，影响美观，这时就可采用下面这种方法</li>
<li>可用前面所讲的bfc解决margin塌陷问题</li>
</ul>
<hr>
<ul>
<li>浮动元素产生了浮动流：所有产生了浮动流的元素，块级元素看不到他们</li>
<li>产生了bfc的元素、文本类型属性(包括<code>inline</code> <code>inline-block</code>的）文本都能看到浮动元素(图片配合float可以形成环绕文字的效果哦！)。</li>
<li>设置了<code>position:absolute</code>和<code>float:left/right</code>的元素会变成inline-block元素</li>
</ul>
<p><a href https: github.com yoursjoker"" title="欢迎stars">个人Github</a>，欢迎stars鼓励一下<br><a href https: yoursjoker.github.io "">个人博客</a>，刚建立不久的博客，有空的大佬可以过来提提建议</p>
]]></content>
      <tags>
        <tag>CSS特别篇</tag>
      </tags>
  </entry>
  <entry>
    <title>let,const ES6入门</title>
    <url>/2020/03/31/let,const%20ES6%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>大家好我是YoursJoker，一个知道很多关于鲁迅名言的前端小萌新，可能鲁迅不会承认（哈哈）<br>个人Blog：<a href="https://yoursjoker.github.io/">https://yoursjoker.github.io/</a> 刚建立，求有空大佬们过来提提意见<br>github:<a href="https://github.com/YoursJoker" target="_blank" rel="noopener">https://github.com/YoursJoker</a> 欢迎star（目前是真空的，我会加油逐步完善）</p>
<h2 id="let命令和const命令"><a href="#let命令和const命令" class="headerlink" title="let命令和const命令"></a>let命令和const命令</h2><p>ES6新增的<code>let</code>命令和<code>const</code>命令和<code>var</code>类似，都是用来<code>声明变量</code>的</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li><code>let</code> <code>const</code>只在声明的<code>块级作用域</code>生效</li>
</ul>
<blockquote>
<ol>
<li>在ES6之前只有 <em>全局作用域</em> 和 <em>函数作用域</em></li>
<li>ES6新增了大括号{}表示的块级作用域，可嵌套</li>
</ol>
</blockquote>
<ul>
<li><code>let</code> <code>const</code>预编译声明不会提前</li>
</ul>
<blockquote>
<ol>
<li><strong>暂时性死区</strong>temporal dead zone简称 TDZ，当使用<code>let</code> <code>const</code>命令时，区块中的<code>let</code> <code>const</code>命令声明的变量从一开始就形成了封闭作用域，凡是在<strong>声明前使用</strong>都会报错</li>
<li><strong>特别注意</strong>：声明前使用typeof也会报错，而ES6之前typeof是一个绝对安全的函数</li>
</ol>
</blockquote>
<ul>
<li>不可以重复定义<blockquote>
<ol>
<li><code>let</code> <code>const</code>在同一个代码块不可以重复定义，否则会报错</li>
</ol>
</blockquote>
<h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3></li>
</ul>
<p>1.<code>for</code>循环中用<code>let</code>声明的迭代变量每次都是<strong>新的变量</strong>，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 6</span><br></pre></td></tr></table></figure>
<p>每一次循环的i其实都是一个<strong>新的变量</strong>,<code>JavaScript</code><strong>引擎内部</strong>会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算</p>
<p>2.<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个<strong>父作用域</strong>，而循环体内部是一个单独的<strong>子作用域</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  <span class="built_in">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  console.log(i);&#125;</span><br><span class="line">// abc// abc// abc</span><br></pre></td></tr></table></figure>
<p><code>a</code>声明了两次，表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域</p>
<h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><p><code>const</code>命令定义时<strong>必须初始化</strong><br><code>const</code>定义的变量为原始值时不可改变，为引用值时对象的属性可以改</p>
<p>###顶层对象的属性</p>
<ol>
<li>在浏览器环境指的是<code>window</code>对象，<code>window</code>也有实体含义，指的是<strong>浏览器的窗口对象</strong></li>
<li>在Node指的是<code>global</code>对象</li>
<li><strong>ES5</strong>中<strong>顶层对象的属性</strong>和<strong>全局变量</strong>是<strong>等价</strong>的</li>
<li>ES6中为了保持兼容性<br>①<code>var</code>命令和<code>function</code>命令声明的全局变量，<strong>依旧是</strong>顶层对象的属性<br>②<code>let</code>命令,<code>const</code>命令,<code>class</code>命令声明的全局变量，<strong>不属于顶层对象的属性</strong></li>
<li><code>globalThis</code>对象，2020新增顶层对象，在<strong>任何环境下<code>globalThis</code>都存在</strong>，都可以拿到顶层对象，指向<strong>全局环境下的this</strong></li>
</ol>
<hr>
<p>ES6入门参考自阮一峰《ES6入门教程》</p>
]]></content>
      <categories>
        <category>ES6入门</category>
      </categories>
      <tags>
        <tag>ES6入门</tag>
      </tags>
  </entry>
  <entry>
    <title>First-aticle</title>
    <url>/2020/03/30/First-aticle/</url>
    <content><![CDATA[<p>无中生有<br>暗度陈仓<br>偷梁换柱</p>
]]></content>
  </entry>
</search>
