<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>模板字符串</title>
    <url>/2020/08/03/%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="ES6总结系列之-模板字符串-篇"><a href="#ES6总结系列之-模板字符串-篇" class="headerlink" title="ES6总结系列之 模板字符串 篇"></a>ES6总结系列之 模板字符串 篇</h1><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>模板字符串由一对<strong>反引号</strong>标识符组成，<code>${}</code>为取值表达式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"Tony"</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span> ;</span><br><span class="line">name+<span class="string">"今年"</span>+age+<span class="string">"岁"</span> ;</span><br><span class="line"><span class="comment">//"Tony今年18岁"</span></span><br><span class="line">等价于</span><br><span class="line"><span class="string">`<span class="subst">$&#123;name&#125;</span>今年<span class="subst">$&#123;age&#125;</span>岁了`</span>;</span><br><span class="line"><span class="comment">//"Tony今年18岁"</span></span><br></pre></td></tr></table></figure>
<p>我们用传统写法表达字符串和变量的拼接写法非常冗余，ES6的模板字符串就可以很好的解决这个问题</p>
<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul>
<li>模板字符串中如需用反引号，需要用\转义<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"Tony"</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="string">`\`<span class="subst">$&#123;name&#125;</span>\`今年<span class="subst">$&#123;age&#125;</span>岁`</span>;</span><br><span class="line"><span class="comment">//"`Tony`今年18岁"</span></span><br></pre></td></tr></table></figure></li>
<li>如果大括号里面的值不是字符串，则按照一般规则装换为字符（toString方法），特别注意的是，如果大括号里面是对象，则将返回<code>[object Object]</code>,如下面代码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="string">`abc<span class="subst">$&#123;obj&#125;</span>`</span>;</span><br><span class="line"><span class="comment">//"abc[object Object]"</span></span><br></pre></td></tr></table></figure>


<ul>
<li>大括号里面就是执行JavaScript代码，因此如果大括号内部是字符串，就会将原样输出<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">大括号里面是表达式，计算后输出</span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span></span><br><span class="line"><span class="comment">// "1 + 2 = 3"</span></span><br><span class="line"></span><br><span class="line">大括号里面是字符串，将原样输出</span><br><span class="line"><span class="string">`<span class="subst">$&#123;<span class="string">"Hello World"</span>&#125;</span>`</span></span><br><span class="line"><span class="comment">//"Hello World"</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>模版字符串所有的<strong>空格和缩进</strong>都会被<strong>保留</strong>在输出之中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newLis = <span class="string">"&lt;li&gt;1:aaa&lt;/li&gt;"</span></span><br><span class="line"><span class="keyword">let</span> ul = </span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;newLis&#125;</span></span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;ul&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;1:aaa&lt;/li&gt;</span></span><br><span class="line"><span class="comment">&lt;/ul&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>模板字符串可嵌套</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"Tony"</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span> ;</span><br><span class="line"><span class="string">`<span class="subst">$&#123;name&#125;</span>今年<span class="subst">$&#123;<span class="string">`<span class="subst">$&#123;age&#125;</span>`</span>&#125;</span>岁了`</span>;</span><br><span class="line"><span class="comment">//"Tony今年18岁了"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>标签模板，函数名+模板字符串，其实就是另外一种调用函数的表达</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">"Tony"</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span> ;</span><br><span class="line">fn<span class="string">`<span class="subst">$&#123;name&#125;</span>今年<span class="subst">$&#123;age&#125;</span>岁了`</span>;</span><br><span class="line"><span class="comment">//&#123; '0': [ '', '今年', '岁了' ], '1': 'Tony', '2': 18 &#125;</span></span><br><span class="line"></span><br><span class="line">等同于</span><br><span class="line">fn([ <span class="string">''</span>, <span class="string">'今年'</span>, <span class="string">'岁了'</span> ], <span class="string">'Tony'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="comment">//&#123; '0': [ '', '今年', '岁了' ], '1': 'Tony', '2': 18 &#125;</span></span><br></pre></td></tr></table></figure>
<p>返回的<code>arguments</code>第一个属性包含了所有的除了变量外的部分，变量在后面逐个显示；注意第一个数组个数总是要比变量多一个，可以把<code>${name}今年${name}岁了</code>看成一条线，把每个变量<code>${name}</code> <code>${name}</code>看成是一个分割点，分割的结果总是分割点多一份；如果变量位于首尾的时候会分割出一个空字符串<code>&#39;&#39;</code>;</p>
</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>模板字符串中如需用反引号，需要用\转义</li>
<li>模版字符串所有的<strong>空格和缩进</strong>都会被<strong>保留</strong>在输出之中</li>
<li>字符串里可以嵌套变量，大括号里内部可以放入<strong>任意的JavaScript表达式</strong>，可以进行运算，以及引用对象属性，函数</li>
<li>模板字符串可嵌套</li>
<li>使用标签模板，注意<code>arguments</code>第一个数包含所有非变量部分，且数量总比变量多一个</li>
</ul>
<hr>
<p>ES6总结系列参考自阮一峰大神的《ES6入门教程》</p>
]]></content>
      <categories>
        <category>ES6入门</category>
      </categories>
      <tags>
        <tag>ES6入门</tag>
      </tags>
  </entry>
  <entry>
    <title>解构赋值</title>
    <url>/2020/08/03/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<h1 id="ES6总结系列之-变量的解构赋值-篇"><a href="#ES6总结系列之-变量的解构赋值-篇" class="headerlink" title="ES6总结系列之 变量的解构赋值 篇"></a>ES6总结系列之 变量的解构赋值 篇</h1><p>变量的解构赋值：<strong>分解</strong>一个对象的结构，对变量进行<strong>赋值</strong>，前提：等号两边的<strong>模式相同</strong></p>
<h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><p>可从数组中提取值，按照<strong>对应位置</strong>，对变量赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"> <span class="comment">//a=1,b=2,c=3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , ,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]; </span><br><span class="line"><span class="comment">//省略赋值  c=3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [[b], c]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="comment">//嵌套解构 a=1,c=2,c=3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a] = [];</span><br><span class="line"><span class="comment">//结构不成功，变量的的值就等于undefined， 所以a = undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>，j = <span class="number">1</span>] = [<span class="literal">undefined</span>, <span class="literal">null</span>];</span><br><span class="line"><span class="comment">//x = 1; j = null;</span></span><br><span class="line"><span class="comment">//解构指定默认值， 只有严格等于(===)undefined是才起作用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认值为表达式时，其求值时惰性的，即需要用时才计算，如下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br><span class="line"><span class="comment">//上面代码中，因为x能取到值，所以函数f根本不会执行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];     <span class="comment">// x=1; y=1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];    <span class="comment">// x=2; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError: y is not defined</span></span><br><span class="line"><span class="comment">//默认值可以引用解构赋值的其他变量，但该变量必须已经声明</span></span><br><span class="line"><span class="comment">//上面最后一个表达式之所以会报错，是因为x用y做默认值时，y还没有声明。</span></span><br></pre></td></tr></table></figure>

<h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><p>对象的属性<strong>没有次序</strong>，变量必须与属性<strong>同名</strong>，才能取到正确的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="comment">//foo = 'aaa';  bar = 'bbb';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//变量名与属性名不一样,应写成</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span> : a, <span class="attr">bar</span> : b &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="comment">//a = 'aaa'; b = 'bbb'</span></span><br><span class="line"><span class="comment">//foo = undefined; bar = underfined;</span></span><br><span class="line"><span class="comment">//对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="comment">//baz = undefined  找不到名为baz的属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line"><span class="comment">//y = 3  指定默认值</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line">a <span class="comment">// "h"</span></span><br><span class="line">b <span class="comment">// "e"</span></span><br><span class="line">c <span class="comment">// "l"</span></span><br><span class="line">d <span class="comment">// "l"</span></span><br><span class="line">e <span class="comment">// "o"</span></span><br><span class="line"></span><br><span class="line">类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。</p>
<h2 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;&#125;)</span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。</p>
<h2 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特别注意,当大括号位于行首时，JavaScript 引擎会将&#123;x&#125;理解成一个代码块，从而发生语法错误。，可通过加圆括号解决，如下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">仅赋值语句的非模式部分，可以使用圆括号。</span><br><span class="line"></span><br><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<h2 id="总结要点"><a href="#总结要点" class="headerlink" title="总结要点"></a>总结要点</h2><ul>
<li>解构赋值<strong>本质</strong>是<strong>对象的解构</strong>，只要等号<strong>右边</strong>的值<strong>不是对象或数组</strong>，就先将其<strong>转为对象</strong>。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</li>
<li>只要某种数据结构具有 Iterator 接口，就可以用于数组的解构赋值，如arguments类数组对象，NodeList类数组对象</li>
<li>对象的解构赋值可以取到<strong>继承的属性</strong></li>
<li>默认值生效的条件是，解构的值<strong>严格</strong>等于undefined</li>
<li>仅赋值语句的非模式部分，可以使用圆括号。</li>
</ul>
<hr>
<ul>
<li><a href https: github.com yoursjoker"" title="欢迎stars">个人Github</a>，欢迎star鼓励一下</li>
<li>ES6总结系列参考自阮一峰《ECMAScript6入门》</li>
</ul>
]]></content>
      <categories>
        <category>ES6入门</category>
      </categories>
      <tags>
        <tag>ES6入门</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的CSS之BFC和margin塌陷</title>
    <url>/2020/04/02/BFC-MarginCollapse/</url>
    <content><![CDATA[<h2 id="CSS之BFC，margin塌陷篇"><a href="#CSS之BFC，margin塌陷篇" class="headerlink" title="CSS之BFC，margin塌陷篇"></a>CSS之BFC，margin塌陷篇</h2><p>大家好，我是YoursJoker，想要走出大山的一个小菜鸟，今天将用简单易懂的语言，让大家快速了解和掌握CSS中的BFC和margin塌陷（本人新手一枚，各位大佬们多多包涵）</p>
<h3 id="何为BFC"><a href="#何为BFC" class="headerlink" title="何为BFC"></a>何为BFC</h3><p>BFC就是块级格式化上下文<code>block formatting context</code></p>
<hr>
<h3 id="BFC特性："><a href="#BFC特性：" class="headerlink" title="BFC特性："></a>BFC特性：</h3><ul>
<li>BFC就是页面上的一个<strong>隔离的独立容器</strong>，容器里的子元素不会影响到外面的元素</li>
<li>计算BFC高度时，浮动元素会被计算进去，可用于<strong>清除浮动</strong></li>
<li>内部的Box会在垂直方向，从顶部开始一个接一个的放置，相当于文档流</li>
<li>Box垂直方向的距离由margin决定，会<strong>叠加</strong>，而不是取<code>margin-bottom</code>和<code>margin-top</code>的最大值，可<strong>解决margin塌陷</strong>，关于margin塌陷滑下手指就能看到啦</li>
</ul>
<hr>
<h3 id="触发bfc条件"><a href="#触发bfc条件" class="headerlink" title="触发bfc条件"></a>触发bfc条件</h3><ul>
<li>position：absolute/fixed</li>
<li>display:inline-block</li>
<li>float:right/left</li>
<li>overflow:不为visible(<code>scroll</code>/<code>hidden</code>/<code>auto</code>)</li>
</ul>
<hr>
<h3 id="margin塌陷"><a href="#margin塌陷" class="headerlink" title="margin塌陷"></a>margin塌陷</h3><ul>
<li>兄弟元素：<strong>垂直方向</strong>的<code>margin</code>会出现合并，即只取前一个元素margin-bottom或后一个元素margin-top两者的较大值；<strong>水平方向</strong>不会出现合并，会正常叠加</li>
<li>父子元素：子元素设置<code>margin-top</code>时会忽视父元素上边,有点像挡不住子元素，子元素“逃”出去了，干说不是很很清楚，直接上代码吧<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;div class=<span class="string">"father"</span>&gt;              //父元素红色</span><br><span class="line">	&lt;div class=<span class="string">"son"</span>&gt;&lt;/div&gt;     //子元素黑色</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.father&#123;</span><br><span class="line">	width: 200px;</span><br><span class="line">	height: 200px;</span><br><span class="line">	background-color: <span class="comment">#f00;</span></span><br><span class="line">	&#125;</span><br><span class="line">.item1&#123;</span><br><span class="line">	margin-top: 20px;         //子元素设置margin-top</span><br><span class="line">	width: 50px;</span><br><span class="line">	height: 50px;</span><br><span class="line">	background-color: <span class="comment">#000;</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<img src="https://user-gold-cdn.xitu.io/2020/4/2/17136db2299cfdc0?w=252&h=252&f=png&s=1824" alt title="理想中的样子"> <img src="https://user-gold-cdn.xitu.io/2020/4/2/17136db4bffaab8f?w=250&h=281&f=png&s=1773" alt title="可现实呜呜呜"><br>理想的样子是子元素距离父元素上边距<code>20px</code>,可实际是子元素直接“忽略”了父元素<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3></li>
<li>最直接给父元素设置<code>border-wide</code>，可我们往往不需要这个边框，影响美观，这时就可采用下面这种方法</li>
<li>可用前面所讲的bfc解决margin塌陷问题</li>
</ul>
<hr>
<ul>
<li>浮动元素产生了浮动流：所有产生了浮动流的元素，块级元素看不到他们</li>
<li>产生了bfc的元素、文本类型属性(包括<code>inline</code> <code>inline-block</code>的）文本都能看到浮动元素(图片配合float可以形成环绕文字的效果哦！)。</li>
<li>设置了<code>position:absolute</code>和<code>float:left/right</code>的元素会变成inline-block元素</li>
</ul>
<p><a href https: github.com yoursjoker"" title="欢迎stars">个人Github</a>，欢迎stars鼓励一下<br><a href https: yoursjoker.github.io "">个人博客</a>，刚建立不久的博客，有空的大佬可以过来提提建议</p>
]]></content>
      <categories>
        <category>CSS特别篇</category>
      </categories>
      <tags>
        <tag>CSS特别篇</tag>
      </tags>
  </entry>
  <entry>
    <title>let,const ES6入门</title>
    <url>/2020/03/31/let,const%20ES6%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>大家好我是YoursJoker，一个知道很多关于鲁迅名言的前端小萌新，可能鲁迅不会承认（哈哈）<br>个人Blog：<a href="https://yoursjoker.github.io/">https://yoursjoker.github.io/</a> 刚建立，求有空大佬们过来提提意见<br>github:<a href="https://github.com/YoursJoker" target="_blank" rel="noopener">https://github.com/YoursJoker</a> 欢迎star（目前是真空的，我会加油逐步完善）</p>
<h2 id="let命令和const命令"><a href="#let命令和const命令" class="headerlink" title="let命令和const命令"></a>let命令和const命令</h2><p>ES6新增的<code>let</code>命令和<code>const</code>命令和<code>var</code>类似，都是用来<code>声明变量</code>的</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li><code>let</code> <code>const</code>只在声明的<code>块级作用域</code>生效</li>
</ul>
<blockquote>
<ol>
<li>在ES6之前只有 <em>全局作用域</em> 和 <em>函数作用域</em></li>
<li>ES6新增了大括号{}表示的块级作用域，可嵌套</li>
</ol>
</blockquote>
<ul>
<li><code>let</code> <code>const</code>预编译声明不会提前</li>
</ul>
<blockquote>
<ol>
<li><strong>暂时性死区</strong>temporal dead zone简称 TDZ，当使用<code>let</code> <code>const</code>命令时，区块中的<code>let</code> <code>const</code>命令声明的变量从一开始就形成了封闭作用域，凡是在<strong>声明前使用</strong>都会报错</li>
<li><strong>特别注意</strong>：声明前使用typeof也会报错，而ES6之前typeof是一个绝对安全的函数</li>
</ol>
</blockquote>
<ul>
<li>不可以重复定义<blockquote>
<ol>
<li><code>let</code> <code>const</code>在同一个代码块不可以重复定义，否则会报错</li>
</ol>
</blockquote>
<h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3></li>
</ul>
<p>1.<code>for</code>循环中用<code>let</code>声明的迭代变量每次都是<strong>新的变量</strong>，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 6</span><br></pre></td></tr></table></figure>
<p>每一次循环的i其实都是一个<strong>新的变量</strong>,<code>JavaScript</code><strong>引擎内部</strong>会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算</p>
<p>2.<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个<strong>父作用域</strong>，而循环体内部是一个单独的<strong>子作用域</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">  <span class="built_in">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  console.log(i);&#125;</span><br><span class="line">// abc// abc// abc</span><br></pre></td></tr></table></figure>
<p><code>a</code>声明了两次，表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域</p>
<h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><p><code>const</code>命令定义时<strong>必须初始化</strong><br><code>const</code>定义的变量为原始值时不可改变，为引用值时对象的属性可以改</p>
<p>###顶层对象的属性</p>
<ol>
<li>在浏览器环境指的是<code>window</code>对象，<code>window</code>也有实体含义，指的是<strong>浏览器的窗口对象</strong></li>
<li>在Node指的是<code>global</code>对象</li>
<li><strong>ES5</strong>中<strong>顶层对象的属性</strong>和<strong>全局变量</strong>是<strong>等价</strong>的</li>
<li>ES6中为了保持兼容性<br>①<code>var</code>命令和<code>function</code>命令声明的全局变量，<strong>依旧是</strong>顶层对象的属性<br>②<code>let</code>命令,<code>const</code>命令,<code>class</code>命令声明的全局变量，<strong>不属于顶层对象的属性</strong></li>
<li><code>globalThis</code>对象，2020新增顶层对象，在<strong>任何环境下<code>globalThis</code>都存在</strong>，都可以拿到顶层对象，指向<strong>全局环境下的this</strong></li>
</ol>
<hr>
<p>ES6入门参考自阮一峰《ES6入门教程》</p>
]]></content>
      <categories>
        <category>ES6入门</category>
      </categories>
      <tags>
        <tag>ES6入门</tag>
      </tags>
  </entry>
  <entry>
    <title>First-aticle</title>
    <url>/2020/03/30/First-aticle/</url>
    <content><![CDATA[<p>无中生有<br>暗度陈仓<br>偷梁换柱</p>
]]></content>
  </entry>
</search>
